什么是迭代协议
迭代器是什么，迭代器是访问集合内元素的一种方式，一般用来遍历数据

迭代器和以下标访问方式不一样，迭代器是不能返回的并且不能切片，迭代器提供了一种惰性方式数据的方式

可迭代的类型和迭代器是不一样的

以下标取值背后的原理是 __getitem__ 
凡是可以迭代的都实现了该迭代协议：__iter__，在迭代的时候默认调用该方法转化为迭代器


迭代器的核心是_next__方法

比如list只实现了__iter__并没有实现__next__
可以理解为迭代器来管理可迭代对象
Iterable是可迭代类型
Iterator是迭代器类型
迭代器和可迭代对象都实现了__iter__方法 只不过迭代器的__iter__是return self，可迭代对象是return 一个迭代器
list只是Iterable不是Iterator

使用iter()方法可以把可迭代类型转换为迭代器

当对一个对象进行for循环的时候 他会默认的调用iter()即__iter__,如果没写该方法（或者返回self），会默认的创建一个迭代器，然后默认配合__next__方法（__next__方法又默认根据__getitem__方法）转化为迭代器，如果__getitem__也没写就会报错。
如果写__iter__方法一定要返回一个迭代器

for循环实际上是调用迭代器的iter或next方法

总结 只实现__iter__是可迭代类型，同时实现了__next__的是迭代器


可迭代类型 ：只实现 __iter__  ，这个函数要return一个迭代器，没写的话默认生成
迭代器： 实现了__iter__ 和 __next__   注意迭代器的__iter__ return 自己

当可迭代类型进行迭代的时候， 会由它的__iter__函数生成的迭代器配合__getitem__方法（没有会报错） 转化为一个新的迭代器
我理解的是 实际上就是迭代器配合__getitem__帮迭代对象实现了__next__方法

循环的时候实际上就是调用了next方法。





新总结：
首先生成器就是迭代器的一种
不写__iter__只写 __next__不能迭代
写了__iter__ 要么返回self,要么返回一个自定义的迭代器（例如生成器）
若是返回self，则进行迭代的时候，如for循环 就会去调用__next__
若是返回自定义迭代器，for循环的时候就会去调用__iter__返回的迭代器（也就是说可以不写__next__）
所以说只实现__iter__只是一个可迭代对象 不是迭代器
只实现__next__就什么也不是
二者都实现才是迭代器




