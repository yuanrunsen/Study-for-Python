gil锁使得同一时刻只有一个线程在一个cpu上执行，无法将多个线程映射到多个cpu上 
当gil锁加给某一个线程的时候，并不是说要等到这个线程执行完了才会释放
而是根据这个线程字节码执行了多少和时间片的多少释放的
而且遇到io操作的时候会自动释放 
如果是IO操作的多线程，其实是和单线程的多协程差不多的


例如有两个线程A,B，一个全局变量C
 A是循环1W次每次让C加1
 B是循环1W次每次让C减1

两个线程启动运行结束后结果不是0
这就是因为GIL锁释放了
不然的话GIL如果不释放，会保证加了1W次，减了1W次，结果为0


可能执行如下；

load C
计算C - 1
把结果赋值给C


load C
计算C + 1
把结果赋值给C



例如此时C等于10，正好计算到了C - 1 为9，要把9赋值给C的时候，GIL锁释放切换到了C+1 为11 赋值给了C，C此时等于11，GIL又释放了，切换回去，把9赋值为C，C此时为9，而预期为10.


不要误认为 +1操作和-1操作是 原子操作
它其实可能有多行字节码组成
而python又是基于字节码来实现的
